[TOC]

# 1. 定义
备忘录模式（Memento Pattern）又称为快照模式（Snapshot Pattern ）或令牌模式（Token Pattern），是指在不破坏封装的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态，属于行为型模式
```
原文∶Without violating encapsulation， capture and externalize an object's internal state so that the object can be restored to this state later
```

在软件系统中，备忘录模式可以为我们提供一种"后悔药"的机制，它通过存储系统各个历史状态的快照，使得我们可以在任一时刻将系统回滚到某一个历史状态。

备忘录模式本质是从发起人实体类（Originator）隔离存储功能，降低实体类的职责。同时由于存储信息（Memento）独立，且存储信息的实体交由管理类（Caretaker）管理，则可以通过为管理类扩展额外的功能对存储信息进行扩展操作（比如增加历史快照功能…）

# 2. 应用场景
对于我们程序员来说，可能天天都在使用备忘录模式，比如我们每天使用的 Git、SVN 都可以提供一种代码版本撤回的功能。还有一个比较贴切的现实场景应该是游戏的存档功能，通过将游戏当前进度存储到本地文件系统或数据库中，使得下次继续游戏时，玩家可以从之前的位置继续进行
![](https://huaweirookie.oss-cn-shenzhen.aliyuncs.com/20200807150707.png)

备忘录模式适用于以下应用场景
* 需要保存历史快照的场景
* 希望在对象之外保存状态，且除了自己其他类对象无法访问状态保存具体内容。首先来看下备忘录模式的通用 UML类图
![](https://huaweirookie.oss-cn-shenzhen.aliyuncs.com/20200807154356.png)

从UML类图中，我们可以看到，备忘录模式主要包含三种角色
* 发起人角色（Originator）∶负责创建一个备忘录，记录自身需要保存的状态;具备状态回滚功能
* 备忘录角色（Memento）∶用于存储 Originator的内部状态，且可以防止Originator 以外的对象进行访问
* 备忘录管理员角色（Caretaker）∶负责存储，提供管理备忘录（Memento），无法对备忘录内容进行操作和访问

# 3. 利用压栈管理落地备忘录模式
我们肯定都用过网页中的富文本编辑器，编辑器中的通常会附带草稿箱、撤销等这样的操作。下面我们用一段带代码来实现一个这样的功能。假设，我们在GPer社区中发布一篇文章，文章编辑的过程需要花很长时间，中间也会不停地撤销、修改。甚至可能要花好几天才能写出一篇精品文章，因此可能会将已经编辑好的内容实时保存到草稿箱

首先创建发起人角色编辑器 Editor 类
```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Editor {
    private String title;
    private String content;
    private String imgs;

    public ArticleMemento saveToMemento(){
        ArticleMemento articleMemento = new ArticleMemento(this.title,this.content,this.imgs);
        return articleMemento;
    }

    public void undoFromMemento(ArticleMemento articleMemento){
        this.title = articleMemento.getTitle();
        this.content = articleMemento.getContent();
        this.imgs = articleMemento.getImgs();
    }
}
```

然后创建备忘录角色 ArticleMemento 类
```java
@Data
@AllArgsConstructor
public class ArticleMemento {
    private String title;
    private String content;
    private String imgs;
}
```

最后创建备忘录管理角色草稿箱 DraftsBox 类
```java
public class DraftsBox {
    private final Stack<ArticleMemento> STACK = new Stack<ArticleMemento>();

    public ArticleMemento getMemento(){
        ArticleMemento articleMemento = STACK.pop();
        return articleMemento;
    }

    public void addMemento(ArticleMemento articleMemento){
        STACK.push(articleMemento);
    }
}
```

草稿箱中定义的Stack类是Vector的一个子类，它实现了一个标准的后进先出的栈。主要定义了以下方法
| 方法定义 | 方法描述 |
| --- | --- |
| boolean empty() | 测试堆栈是否为空 |
| Object peek() | 查看堆栈顶部的对象，但不从堆栈中移除它 |
| Object pop() | 移除堆栈顶部的对象，并作为此函数的值返回该对象 |
| Object push(Object element) | 把对象压入堆栈顶部 |
| int search(Object element) | 返回对象在堆栈中的位置，以1为基数 |

最后编写客户端测试代码
```java
public class Test {
    public static void main(String[] args) {
        DraftsBox draftsBox = new DraftsBox();

        Editor editor = new Editor("我是这样手写Spring的，麻雀虽小五脏俱全",
                "本文节选自《Spring5核心原理与30个类手写实战》一书，Tom著，电子工业出版社出版。",
                "35576a9ef6fc407aa088eb8280fb1d9d.png");

        ArticleMemento articleMemento = editor.saveToMemento();
        draftsBox.addMemento(articleMemento);

        System.out.println("标题：" + editor.getTitle() + "\n" +
                            "内容：" + editor.getContent() + "\n" +
                            "插图：" + editor.getImgs() + "\n暂存成功");

        System.out.println("完整的信息" + editor);

        System.out.println("==========首次修改文章===========");
        editor.setTitle("【Tom原创】我是这样手写Spring的，麻雀虽小五脏俱全");
        editor.setContent("本文节选自《Spring5核心原理与30个类手写实战》一书，Tom著");

        System.out.println("==========首次修改文章完成===========");

        System.out.println("完整的信息" + editor);

        articleMemento = editor.saveToMemento();

        draftsBox.addMemento(articleMemento);

        System.out.println("==========保存到草稿箱===========");


        System.out.println("==========第2次修改文章===========");
        editor.setTitle("手写Spring");
        editor.setContent("本文节选自《Spring5核心原理与30个类手写实战》一书，Tom著");
        System.out.println("完整的信息" + editor);
        System.out.println("==========第2次修改文章完成===========");

        System.out.println("==========第1次撤销===========");
        articleMemento = draftsBox.getMemento();
        editor.undoFromMemento(articleMemento);
        System.out.println("完整的信息" + editor);
        System.out.println("==========第1次撤销完成===========");

        System.out.println("==========第2次撤销===========");
        articleMemento = draftsBox.getMemento();
        editor.undoFromMemento(articleMemento);
        System.out.println("完整的信息" + editor);
        System.out.println("==========第2次撤销完成===========");
    }
}
```

运行结果
```
标题：我是这样手写Spring的，麻雀虽小五脏俱全
内容：本文节选自《Spring5核心原理与30个类手写实战》一书，Tom著，电子工业出版社出版。
插图：35576a9ef6fc407aa088eb8280fb1d9d.png
暂存成功
完整的信息Editor(title=我是这样手写Spring的，麻雀虽小五脏俱全, content=本文节选自《Spring5核心原理与30个类手写实战》一书，Tom著，电子工业出版社出版。, imgs=35576a9ef6fc407aa088eb8280fb1d9d.png)
==========首次修改文章===========
==========首次修改文章完成===========
完整的信息Editor(title=【Tom原创】我是这样手写Spring的，麻雀虽小五脏俱全, content=本文节选自《Spring5核心原理与30个类手写实战》一书，Tom著, imgs=35576a9ef6fc407aa088eb8280fb1d9d.png)
==========保存到草稿箱===========
==========第2次修改文章===========
完整的信息Editor(title=手写Spring, content=本文节选自《Spring5核心原理与30个类手写实战》一书，Tom著, imgs=35576a9ef6fc407aa088eb8280fb1d9d.png)
==========第2次修改文章完成===========
==========第1次撤销===========
完整的信息Editor(title=【Tom原创】我是这样手写Spring的，麻雀虽小五脏俱全, content=本文节选自《Spring5核心原理与30个类手写实战》一书，Tom著, imgs=35576a9ef6fc407aa088eb8280fb1d9d.png)
==========第1次撤销完成===========
==========第2次撤销===========
完整的信息Editor(title=我是这样手写Spring的，麻雀虽小五脏俱全, content=本文节选自《Spring5核心原理与30个类手写实战》一书，Tom著，电子工业出版社出版。, imgs=35576a9ef6fc407aa088eb8280fb1d9d.png)
==========第2次撤销完成===========
```

# 4. 备忘录模式在源码中的体现
备忘录模式在框架源码中的应用也是比较少的，主要还是结合具体的应用场景来使用。我在JDK 源码一顿找，目前为止还是没找到具体的应用，包括在MyBatis中也没有找到对应的源码。如果有小 伙伴找 到可以联系我。在 Spring 的 webflow 源 码 中还是 找到一个StateManageableMessageContext接口，我们来看它的源代码
```java
public interface StateManageableMessageContext extends MessageContext {
    Serializable createMessagesMemento();

    void restoreMessages(Serializable var1);

    void setMessageSource(MessageSource var1);
}
```

我们看到有一个createMessagesMemento（）方法，创建一个消息备忘录。可以打开它的实现类
```java
public class DefaultMessageContext implements StateManageableMessageContext {
    private static final Log logger = LogFactory.getLog(DefaultMessageContext.class);
    private MessageSource messageSource;
    private Map<Object, List<Message>> sourceMessages;

    public DefaultMessageContext() {
        this.sourceMessages = new NamelessClass_1(new LinkedHashMap());
        this.init((MessageSource)null);
    }

    public DefaultMessageContext(MessageSource messageSource) {
        class NamelessClass_1 extends AbstractCachingMapDecorator<Object, List<Message>> {
            NamelessClass_1(Map x0) {
                super(x0);
            }

            protected List<Message> create(Object source) {
                return new ArrayList();
            }
        }

        this.sourceMessages = new NamelessClass_1(new LinkedHashMap());
        this.init(messageSource);
    }

    public MessageSource getMessageSource() {
        return this.messageSource;
    }

    public Message[] getAllMessages() {
        List<Message> messages = new ArrayList();
        Iterator i$ = this.sourceMessages.values().iterator();

        while(i$.hasNext()) {
            List<Message> list = (List)i$.next();
            messages.addAll(list);
        }

        return (Message[])messages.toArray(new Message[messages.size()]);
    }

    public Message[] getMessagesBySource(Object source) {
        List<Message> messages = (List)this.sourceMessages.get(source);
        return (Message[])messages.toArray(new Message[messages.size()]);
    }

    public Message[] getMessagesByCriteria(MessageCriteria criteria) {
        List<Message> messages = new ArrayList();
        Iterator i$ = this.sourceMessages.values().iterator();

        while(i$.hasNext()) {
            List<Message> sourceMessages = (List)i$.next();
            Iterator i$ = sourceMessages.iterator();

            while(i$.hasNext()) {
                Message message = (Message)i$.next();
                if (criteria.test(message)) {
                    messages.add(message);
                }
            }
        }

        return (Message[])messages.toArray(new Message[messages.size()]);
    }

    public boolean hasErrorMessages() {
        Iterator i$ = this.sourceMessages.values().iterator();

        while(i$.hasNext()) {
            List<Message> sourceMessages = (List)i$.next();
            Iterator i$ = sourceMessages.iterator();

            while(i$.hasNext()) {
                Message message = (Message)i$.next();
                if (message.getSeverity() == Severity.ERROR) {
                    return true;
                }
            }
        }

        return false;
    }

    public void addMessage(MessageResolver messageResolver) {
        Locale currentLocale = LocaleContextHolder.getLocale();
        if (logger.isDebugEnabled()) {
            logger.debug("Resolving message using " + messageResolver);
        }

        Message message = messageResolver.resolveMessage(this.messageSource, currentLocale);
        List<Message> messages = (List)this.sourceMessages.get(message.getSource());
        if (logger.isDebugEnabled()) {
            logger.debug("Adding resolved message " + message);
        }

        messages.add(message);
    }

    public void clearMessages() {
        this.sourceMessages.clear();
    }

    public Serializable createMessagesMemento() {
        return new LinkedHashMap(this.sourceMessages);
    }

    public void restoreMessages(Serializable messagesMemento) {
        this.sourceMessages.putAll((Map)messagesMemento);
    }

    public void setMessageSource(MessageSource messageSource) {
        if (messageSource == null) {
            messageSource = new DefaultMessageContext.DefaultTextFallbackMessageSource((NamelessClass_1)null);
        }

        this.messageSource = (MessageSource)messageSource;
    }

    private void init(MessageSource messageSource) {
        this.setMessageSource(messageSource);
        this.sourceMessages.get((Object)null);
    }

    public String toString() {
        return (new ToStringCreator(this)).append("sourceMessages", this.sourceMessages).toString();
    }

    private static class DefaultTextFallbackMessageSource extends AbstractMessageSource {
        private DefaultTextFallbackMessageSource() {
        }

        protected MessageFormat resolveCode(String code, Locale locale) {
            return null;
        }
    }
}
```

我们看到其主要逻辑就相当于是给 Message留一个备份，以备恢复之用。

# 5. 优缺点
## 5.1 优点
* 简化发起人实体类（Originator）职责，隔离状态存储与获取，实现了信息的封装，客户端无需关心状态的保存细节
* 提供状态回滚功能

# 5.2 缺点
* 消耗资源∶如果需要保存的状态过多时，每一次保存都会消耗很多内存